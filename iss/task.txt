Написать класс с интерфейсом:

struct IReceiver
{
	virtual void Receive(const char* data, unsigned int size) = 0;
};

На вход которого (через интерфейс IReceiver) блоками различного размера непрерывно поступает поток данных.

Сам поток представляет собой последовательность пакетов двух типов (пакеты идут вперемешку):

1. Если пакет начинается с байта 0x24 (1 байт), то это "бинарный" пакет. За 0x24 следует размер данных пакета в байтах (четырёхбайтовое целое, little endian), а затем сами данные. "Бинарный" пакет нулевого размера возможен.

2. Иначе (если первый байт в пакете не 0x24) пакет текстовый. Текстовый пакет заканчивается на последовательность байт «\r\n\r\n».

Как только обнаружен конец пакета, необходимо данные пакета передать потребителю через callback-интерфейс:

struct ICallback
{
	virtual void BinaryPacket(const char* data, unsigned int size) = 0;
	virtual void TextPacket(const char* data, unsigned int size) = 0;
};

В обе функции за раз передаётся всё содержимое пакета целиком, без заголовков и «\r\n\r\n».

Данные одного пакета идут в потоке строго последовательно, данные разных пакетов не перемешиваются. Нет никакой привязки блока, поступающего на вход IReceiver к размерам и границам пакетов, на несколько блоков может разделиться в том числе размер бинарного пакета и терминатор текстового.
Класс должен быть как можно эффективнее при следующих условиях: средний поток, подаваемый на вход – 500 Mbit/s, средняя длина блока входных данных – 1024 байт.

В решении важна простота и читаемость.

-------------------------------------------------


1. Должны ли пакеты передаваться через callback-интерфейс строго в той же последовательности, в какой они получены?
    пакеты всегда передаются в строгом порядке. т.е. пока все байты одного пакета не будут переданы в ресивер, данные другого пакета в потоке данных оказаться не могут
    В ICallback пакеты должны поступать ровно в том же порядке, как они поступают на вход Receiver'а.
2. Нужно ли ожидать обработки пакета callback-интерфейсом? (Иными словами -- методы callback-интерфейса блокирующие?)
    можете считать, что методы ICallback работают очень быстро (т.е. их временем работы можно пренебречь)
3. Кто управляет участком памяти, передаваемым методу IReceiver::Receive? Какие есть гарантии по времени, сколько эта память будет оставаться выделенной и неизменной?
    владение память внутрь ресивера не переходит. Т.е. она может быть освобождена как только Receive вернёт управление
4. Какие допустимые байты в текстовом пакете?
    будем считать, что у текстового потока есть только одно ограничение - он не может начинаться с байта 0x24
5. Какая предельная длина текстового пакета?
    да вроде нет особых, если нужная какая-то определённость, пусть 1Gb будет.

